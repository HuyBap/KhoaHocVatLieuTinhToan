# -*- coding: utf-8 -*-
"""MNIST_TensorFlow.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RN5WtL5oEGXVHzcNzkY5-GfREBCyMgRS
"""

import cv2
import numpy as np
import pandas as pd
import tensorflow as tf
import matplotlib.pyplot as plt
from tensorflow.keras import layers, models
from tensorflow.keras.models import load_model
from scipy.ndimage import rotate, gaussian_filter

# Tải bộ dữ liệu từ TensorFlow
(x_train, y_train), (x_test, y_test) = tf.keras.datasets.mnist.load_data()

# Chuẩn hóa dữ liệu (đưa pixel về khoảng [0,1])
x_train, x_test = x_train / 255.0, x_test / 255.0

# Reshape thành định dạng phù hợp với CNN (thêm chiều kênh màu)
x_train = x_train.reshape(-1, 28, 28, 1)
x_test = x_test.reshape(-1, 28, 28, 1)

# Hiển thị 9 ảnh từ tập huấn luyện
plt.figure(figsize=(10, 5))
for i in range(9):
    plt.subplot(3, 3, i + 1)
    plt.imshow(x_train[i].reshape(28, 28), cmap='gray')
    plt.title(f"Label: {y_train[i]}")
    plt.axis('off')
plt.show()

model = models.Sequential([
    layers.Conv2D(32, (3,3), activation='relu', input_shape=(28, 28, 1)),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, (3,3), activation='relu'),
    layers.MaxPooling2D((2,2)),
    layers.Conv2D(64, (3,3), activation='relu'),
    layers.Flatten(),
    layers.Dense(128, activation='relu'),
    layers.Dense(10, activation='softmax')  # 10 lớp đầu ra (số từ 0-9)
])

# Compile mô hình
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

history = model.fit(x_train, y_train, epochs=5, validation_data=(x_test, y_test))

test_loss, test_acc = model.evaluate(x_test, y_test)
print(f"Độ chính xác trên tập test: {test_acc:.4f}")

acc = history.history['accuracy']
val_acc = history.history['val_accuracy']
loss = history.history['loss']
val_loss = history.history['val_loss']

epochs = range(1, len(acc) + 1)

# Vẽ biểu đồ Accuracy
plt.figure(figsize=(12, 5))

plt.subplot(1, 2, 1)
plt.plot(epochs, acc, 'b', label='Training Accuracy')
plt.plot(epochs, val_acc, 'r', label='Validation Accuracy')
plt.xlabel('Epochs')
plt.ylabel('Accuracy')
plt.title('Training & Validation Accuracy')
plt.legend()

# Vẽ biểu đồ Loss
plt.subplot(1, 2, 2)
plt.plot(epochs, loss, 'b', label='Training Loss')
plt.plot(epochs, val_loss, 'r', label='Validation Loss')
plt.xlabel('Epochs')
plt.ylabel('Loss')
plt.title('Training & Validation Loss')
plt.legend()

plt.show()

predictions = model.predict(x_test[:9])

plt.figure(figsize=(10, 5))
for i in range(9):
    plt.subplot(3, 3, i + 1)
    plt.imshow(x_test[i].reshape(28, 28), cmap='gray')
    plt.title(f"Dự đoán: {np.argmax(predictions[i])}")
    plt.axis('off')
plt.show()

# Lưu mô hình dưới dạng tệp .h5
model.save("mnist_cnn_model.h5")
print("Mô hình đã được lưu thành công.")

# Load mô hình đã lưu
model = load_model("mnist_cnn_model.h5")
print("Mô hình đã được tải thành công.")

def preprocess_image(image, rotate_angle=15, blur_sigma=1):
    """
    Xử lý ảnh: xoay một góc ngẫu nhiên và làm mịn bằng Gaussian filter.
    """
    # Xoay ảnh trong khoảng [-rotate_angle, +rotate_angle] độ
    angle = np.random.uniform(-rotate_angle, rotate_angle)
    rotated_image = rotate(image, angle, reshape=False)

    # Làm mịn ảnh bằng Gaussian filter
    smoothed_image = gaussian_filter(rotated_image, sigma=blur_sigma)

    return smoothed_image

def predict_digit(image_path):
    original_img = cv2.imread(image_path)
    original_img_rgb = cv2.cvtColor(original_img, cv2.COLOR_BGR2RGB)

    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    img = cv2.resize(img, (28, 28))

    # Đảo màu nếu nền trắng chữ đen
    if np.mean(img) > 127:
        img = 255 - img

    # Chuẩn hóa pixel về khoảng [0,1]
    img = img / 255.0

    # Lưu ảnh trước khi xử lý bằng scipy
    processed_img_before = img.copy()

    # Xử lý ảnh bằng scipy (xoay và làm mờ)
    processed_img = preprocess_image(img)

    # Định dạng lại để phù hợp với đầu vào của mô hình
    processed_img_input = processed_img.reshape(1, 28, 28, 1)

    prediction = model.predict(processed_img_input)
    predicted_digit = np.argmax(prediction)

    plt.figure(figsize=(12, 4))

    plt.subplot(1, 3, 1)
    plt.imshow(original_img_rgb)
    plt.title("Ảnh Gốc")
    plt.axis('off')

    plt.subplot(1, 3, 2)
    plt.imshow(processed_img_before, cmap='gray')
    plt.title("Ảnh Grayscale 28x28")
    plt.axis('off')

    plt.subplot(1, 3, 3)
    plt.imshow(processed_img, cmap='gray')
    plt.title("Ảnh Sau Xử Lý")
    plt.axis('off')

    plt.show()

    print(f"Dự đoán: {predicted_digit}")

    return predicted_digit

image_path = "/content/7.png"
predicted_number = predict_digit(image_path)